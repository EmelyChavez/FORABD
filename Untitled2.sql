--****************************************************
-- Administración de bases de datos
-- Autor: Erick Varela
-- Contacto: evarela@uca.edu.sv
-- Version: 1.0
--****************************************************

--****************************************************
-- Triggers
--****************************************************
-- Sintaxis básica de los triggers
/*
CREATE [OR REPLACE] TRIGGER trigger_name
	{BEFORE | AFTER | INSTEAD OF} 
	{INSERT | UPDATE [OF column_name] | DELETE}
	ON table_name
	[FOR EACH ROW]
	[WHEN (condition)]
DECLARE
   -- Declaraciones de variables (opcional)
BEGIN
   -- Bloque PL/SQL con la lógica del trigger
END;
*/

--****************************************************
/*
7.1 Crear un trigger que registre cambios de actualización y eliminación en la tabla “detalle_factura”. 
	Crear dos versiones del trigger, el primero “a nivel de consulta” y el segundo “a nivel de filas. 
	Discutir la diferencia.
*/

CREATE TABLE registro_df (
    id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    tipo_transaccion VARCHAR2(10),
    usuario VARCHAR2(30),
    fecha TIMESTAMP
);

-- Trigger a nivel de consulta
CREATE OR REPLACE TRIGGER detalle_factura_registro
    AFTER INSERT OR DELETE 
    ON detalle_factura
DECLARE
    action_type VARCHAR2(10);
    responsible_user VARCHAR2(32);
    action_timestamp TIMESTAMP;
BEGIN
    CASE
        WHEN UPDATING THEN
            action_type := 'UPDATE';
        WHEN DELETING THEN
            action_type := 'DELETE';
    END CASE;
    
    responsible_user := USER;
    action_timestamp := SYSDATE;
    
    INSERT INTO registro_df (tipo_transaccion, usuario, fecha)
        VALUES(action_type,responsible_user,action_timestamp);
    
END;

-- Validando funcionamiento de trigger
DELETE FROM DETALLE_FACTURA WHERE id_factura = 28;
SELECT * FROM registro_df;

-- Trigger a nivel de fila
CREATE OR REPLACE TRIGGER detalle_factura_registro
    AFTER INSERT OR DELETE 
    ON detalle_factura
	FOR EACH ROW
DECLARE
    action_type VARCHAR2(10);
    responsible_user VARCHAR2(32);
    action_timestamp TIMESTAMP;
BEGIN
    CASE
        WHEN UPDATING THEN
            action_type := 'UPDATE';
        WHEN DELETING THEN
            action_type := 'DELETE';
    END CASE;
    
    responsible_user := USER;
    action_timestamp := SYSDATE;
    
    INSERT INTO registro_df (tipo_transaccion, usuario, fecha)
        VALUES(action_type,responsible_user,action_timestamp);
    
END;

-- Insertando datos de prueba
INSERT INTO DETALLE_FACTURA VALUES(28,10,3);
INSERT INTO DETALLE_FACTURA VALUES(28,8,6);
INSERT INTO DETALLE_FACTURA VALUES (28,7,3);
INSERT INTO DETALLE_FACTURA VALUES (28,6,2);
INSERT INTO DETALLE_FACTURA VALUES (28,5,10);

-- Validando funcionamiento de trigger
DELETE FROM DETALLE_FACTURA WHERE id_factura = 28;
SELECT * FROM registro_df;


--****************************************************
/*
7.2. 	Ampliar la funcionalidad del trigger a nivel de filas creado en el ejercicio anterior 
		para que sea capaz de registrar los datos luego de una actualización po eliminación 
		en la tabla “detalle_factura”. Discutir sobre las variables :NEW y :OLD
*/

ALTER TABLE detalle_factura ADD q_new INT NULL;
ALTER TABLE detalle_factura ADD q_old INT NULL;

CREATE OR REPLACE TRIGGER detalle_factura_registro
    AFTER UPDATE OR DELETE 
    ON detalle_factura
    FOR EACH ROW
DECLARE
    action_type VARCHAR2(10);
    responsible_user VARCHAR2(32);
    action_timestamp TIMESTAMP;
    
    df_row REGISTRO_DF%ROWTYPE;
BEGIN
    CASE
        WHEN UPDATING THEN
            df_row.tipo_transaccion := 'UPDATE';
            df_row.q_new := :NEW.cantidad;
            df_row.q_old := :OLD.cantidad;
        WHEN DELETING THEN
            df_row.tipo_transaccion := 'DELETE';
            df_row.q_new := NULL;
            df_row.q_old := :OLD.cantidad;
    END CASE;
    
    df_row.usuario := USER;
    df_row.fecha := SYSDATE;
    
    INSERT INTO registro_df (tipo_transaccion, usuario, fecha, q_new, q_old)
        VALUES(df_row.tipo_transaccion,df_row.usuario,df_row.fecha, df_row.q_new, df_row.q_old);
    
END;

-- Insertando datos de prueba
INSERT INTO DETALLE_FACTURA VALUES(28,10,3);
INSERT INTO DETALLE_FACTURA VALUES(28,8,6);
INSERT INTO DETALLE_FACTURA VALUES (28,7,3);
INSERT INTO DETALLE_FACTURA VALUES (28,6,2);
INSERT INTO DETALLE_FACTURA VALUES (28,5,10);

-- Validando funcionamiento de trigger
UPDATE DETALLE_FACTURA SET CANTIDAD = 12 WHERE id_factura = 28 AND id_producto = 5;
DELETE FROM DETALLE_FACTURA WHERE id_factura = 28;

SELECT * FROM registro_df; 


--****************************************************
/*
7.3 Aplicar una excepción predefinida al bloque PL/SQL del ejemplo práctico 6.5, 
	que valide el mes como  parámetros de entrada para asegurar que el 
	procedimiento se ejecute correctamente.
*/

/*
Solución ejemplo práctico 6.5

CREATE OR REPLACE FUNCTION calculate_bill_total
(bill_id INT)
RETURN FLOAT
AS
    total FLOAT;
BEGIN
    SELECT SUM (p.precio_unidad * df.cantidad)
    INTO total
    FROM FACTURA F, DETALLE_FACTURA DF, PRODUCTO P
    WHERE f.id = df.id_factura
        AND P.id = df.id_producto
        AND F.id = bill_id
    GROUP BY F.id;
    RETURN total;
END;

CREATE OR REPLACE PROCEDURE BEST_SELLER 
    (id_month IN INT, id_employee OUT INT, employee_sales OUT FLOAT)
IS 
BEGIN
    SELECT E.id, SUM(calculate_bill_total (F.id)) total
    INTO id_employee, employee_sales
    FROM EMPLEADO E, FACTURA F 
    WHERE E.id = F.id_empleado
		AND EXTRACT (MONTH FROM F.fecha) = id_month
    GROUP BY E.id, E.nombre
    ORDER BY total DESC
    FETCH FIRST 1 ROWS ONLY;
END;

SET SERVEROUTPUT ON;
DECLARE
    id_employee INT; 
    employee_sales FLOAT;
BEGIN
    BEST_SELLER (11, id_employee, employee_sales);
    DBMS_OUTPUT.PUT_LINE('El empleado con id: ' || id_employee || ', ha generado $' || employee_sales || ' en ganancias');
END;
*/

CREATE OR REPLACE PROCEDURE BEST_SELLER 
    (id_month IN INT, id_employee OUT INT, employee_sales OUT FLOAT)
IS 
BEGIN

	IF id_month NOT BETWEEN 1 AND 12 THEN
		RAISE VALUE_ERROR;
	END IF;
	
    SELECT E.id, SUM(calculate_bill_total (F.id)) total
    INTO id_employee, employee_sales
    FROM EMPLEADO E, FACTURA F 
    WHERE E.id = F.id_empleado
	AND EXTRACT (MONTH FROM F.fecha) = id_month
    GROUP BY E.id, E.nombre
    ORDER BY total DESC
    FETCH FIRST 1 ROWS ONLY;
EXCEPTION
    WHEN VALUE_ERROR THEN
        DBMS_OUTPUT.PUT_LINE('ERROR '||SQLCODE||': valor de entrada no permitido. '||SQLERRM);
END;

SET SERVEROUTPUT ON;
DECLARE
    id_employee INT; 
    employee_sales FLOAT;
BEGIN
    BEST_SELLER (11, id_employee, employee_sales);
    --DBMS_OUTPUT.PUT_LINE('El empleado con id: ' || id_employee || ', ha generado $' || employee_sales || ' en ganancias');
END;


--****************************************************
/*
7.4. 	Aplicar una excepción personalizada al bloque PL/SQL del ejemplo práctico anterior, 
		que valide que el bloque solo se puede ejecutar en horario de trabajo hábil. 
		Asumir el horario laboral de 8:00 AM a 5:00 PM.
*/

CREATE OR REPLACE PROCEDURE BEST_SELLER 
    (id_month IN INT, id_employee OUT INT, employee_sales OUT FLOAT)
IS 
	-- Defining custom exception
	NOT_VALID_EXEC_HOUR EXCEPTION;
	server_hour INT;
BEGIN

	IF id_month NOT BETWEEN 1 AND 12 THEN
		RAISE VALUE_ERROR;
	END IF;
	
	SELECT EXTRACT (HOUR FROM CAST(SYSDATE AS TIMESTAMP)) INTO server_hour;
    IF server_hour NOT BETWEEN 8 AND 17 THEN
        RAISE NOT_VALID_EXEC_HOUR;
    END IF; 
	
    SELECT E.id, SUM(calculate_bill_total (F.id)) total
    INTO id_employee, employee_sales
    FROM EMPLEADO E, FACTURA F 
    WHERE E.id = F.id_empleado
	AND EXTRACT (MONTH FROM F.fecha) = id_month
    GROUP BY E.id, E.nombre
    ORDER BY total DESC
    FETCH FIRST 1 ROWS ONLY;
EXCEPTION
    WHEN VALUE_ERROR THEN
        DBMS_OUTPUT.PUT_LINE('ERROR '||SQLCODE||': valor de entrada no permitido. '||SQLERRM);
	WHEN NOT_VALID_EXEC_HOUR THEN
        DBMS_OUTPUT.PUT_LINE('ERROR: la consulta no se puede realizar en este momento.');
END;

SET SERVEROUTPUT ON;
DECLARE
    id_employee INT; 
    employee_sales FLOAT;
BEGIN
    BEST_SELLER (11, id_employee, employee_sales);
    --DBMS_OUTPUT.PUT_LINE('El empleado con id: ' || id_employee || ', ha generado $' || employee_sales || ' en ganancias');
END;

--****************************************************
/*
7.5. 	Aplicar una excepción denivel interno al bloque PL/SQL del ejemplo práctico anterior, 
		que valide que la consulta realizada tenga datos disponibles.
*/

CREATE OR REPLACE PROCEDURE BEST_SELLER 
    (id_month IN INT, id_employee OUT INT, employee_sales OUT FLOAT)
IS 
	-- Defining custom exception
	NOT_VALID_EXEC_HOUR EXCEPTION;
	server_hour INT;
	
	NOT_AVAILABLE_DATA EXCEPTION; 
	PRAGMA EXCEPTION_INIT (NOT_AVAILABLE_DATA,-16545);
    query_validation INT;
BEGIN

	IF id_month NOT BETWEEN 1 AND 12 THEN
		RAISE VALUE_ERROR;
	END IF;
	
	SELECT EXTRACT (HOUR FROM CAST(SYSDATE AS TIMESTAMP)) INTO server_hour;
    IF server_hour NOT BETWEEN 8 AND 17 THEN
        RAISE NOT_VALID_EXEC_HOUR;
    END IF; 
	

    SELECT COUNT (*)
    INTO  query_validation FROM (
        SELECT E.id, SUM(calculate_bill_total (F.id)) total
        FROM EMPLEADO E, FACTURA F 
        WHERE E.id = F.id_empleado
        AND EXTRACT (MONTH FROM F.fecha) = id_month
        GROUP BY E.id, E.nombre
        ORDER BY total DESC
    );
    
    IF query_validation = 0 THEN
        RAISE NOT_AVAILABLE_DATA;
    END IF;
    
    
    SELECT E.id, SUM(calculate_bill_total (F.id)) total
    INTO id_employee, employee_sales
    FROM EMPLEADO E, FACTURA F 
    WHERE E.id = F.id_empleado
    AND EXTRACT (MONTH FROM F.fecha) = id_month
    GROUP BY E.id, E.nombre
    ORDER BY total DESC
    FETCH FIRST 1 ROWS ONLY;
	
EXCEPTION
    WHEN VALUE_ERROR THEN
        DBMS_OUTPUT.PUT_LINE('ERROR '||SQLCODE||': valor de entrada no permitido. '||SQLERRM);
	WHEN NOT_VALID_EXEC_HOUR THEN
        DBMS_OUTPUT.PUT_LINE('ERROR: la consulta no se puede realizar en este momento.');
    WHEN NOT_AVAILABLE_DATA THEN
        DBMS_OUTPUT.PUT_LINE('ERROR CODIGO'||SQLCODE||': no se pudo procesar su consulta, no hay datos disponibles para el mes solicitado.');
END;


SET SERVEROUTPUT ON;
DECLARE
    id_employee INT; 
    employee_sales FLOAT;
BEGIN
    BEST_SELLER (12, id_employee, employee_sales);
    --DBMS_OUTPUT.PUT_LINE('El empleado con id: ' || id_employee || ', ha generado $' || employee_sales || ' en ganancias');
END;
